// SPDX-License-Identifier: MIT

namespace Fahrenheit.Core;

/// <summary>Represents the method that will handle a Fahrenheit event when the event provides data.</summary>
/// <param name="e">An object that contains the event data.</param>
/// <typeparam name="TArgs">The type of the event data generated by the event.</typeparam>
public delegate void FhEventHandler<in TArgs>(TArgs e)
    where TArgs : allows ref struct;

/// <summary>
///     A replacement of C# events.<br/>
///     Used in Fahrenheit to prevent overriding the load order of mods.<br/>
///     There is no way to unsubscribe from a Fahrenheit event.
/// </summary>
/// <typeparam name="TArgs">The type of the arguments the event accepts.</typeparam>
public class FhEvent<TArgs> where TArgs : allows ref struct {
    private readonly HashSet<FhEventHandler<TArgs>> _handlers = new();

    internal FhEvent() {}

    /// <summary>Subscribe to the event.</summary>
    /// <param name="event_handler">The handler to subscribe to the event with.</param>
    public bool subscribe(FhEventHandler<TArgs> event_handler) {
        // if (initializing_mods) {
        //     _logger.Warn("Tried to subscribe to event outside of mod initialization.")'
        // }

        return /* initializing_mods && */ _handlers.Add(event_handler);
    }

    /// <summary>Invoke the event.</summary>
    /// <param name="args">The arguments to invoke the event with.</param>
    /// <returns>Whether the event has any handlers.</returns>
    internal bool invoke(TArgs args) {
        foreach (FhEventHandler<TArgs> handler in _handlers) {
            handler.Invoke(args);
        }

        return _handlers.Count == 0;
    }
}
